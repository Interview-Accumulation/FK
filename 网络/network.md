
# 前端网络
- https://juejin.cn/post/6940942549305524238
- https://juejin.cn/post/6908327746473033741
- https://juejin.cn/post/6844904021308735502
- https://juejin.cn/post/7269952188927017015
- https://juejin.cn/post/6908327746473033741

## HTTP


### http状态码
* 分类:
  * 1xx - 服务器收到请求。
  * 2xx - 请求成功，如 200。
  * 3xx - 重定向，如 302。
  * 4xx - 客户端错误，如 404。
  * 5xx - 服务端错误，如 500。

* 常见：
  * 200 OK - 成功。
  * 301 Moved Permanently - 永久重定向（配合 location，浏览器自动处理）。
  * 302 Found - 临时重定向（配合 location，浏览器自动处理）。
  * 304 Not Modified - 资源未被修改,使用协商缓存
  * 403 Forbidden - 没权限。
  * 404 Not Found - 资源未找到。
  * 500 Internal Server Error - 服务器错误。
  * 504 Gateway Timeout - 网关超时。

### get和post的区别
- 应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
- 是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
- 安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
- 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。(不同浏览器对URL长度限制不同，如chrome为8182个字符，Safari为80000个字符，Firefox为65536个字符等)
- 参数类型： post 的参数传递支持更多的数据类型。

### 简单请求
简单请求需要满足以下条件：

- 只使用以下HTTP方法之一：GET、HEAD或POST。
- 只使用以下HTTP头部：Accept、Accept-Language、Content-Language、Content-Type。
- Content-Type的值仅限于：application/x-www-form-urlencoded、multipart/form-data或text/plain。

如果一个跨域请求不满足以上所有条件，那么它被认为是非简单请求。对于非简单请求，浏览器会在实际请求（例如PUT、DELETE、PATCH或具有自定义头部和其他Content-Type的POST请求）之前发送OPTIONS请求（**预检请求**）。

### http缓存

##### 强缓存
强缓存不需要客户端向服务端发送请求，有两种响应头实现方案:
* Expires：值是一个绝时间，在这个时间前缓存有效，但是如果本地时间被修改，会导致缓存失效,**在http/1.0中使用**
* Cache-control：值是一个相对时间，单位为秒，资源在这个时间内有效，**在http/1.1中使用**
* expires和cache-control同时存在时，cache-control优先级高于expires

**Expires**
- 即为过期时间，用来指定资源到期的时间，是服务器端的具体的时间点，由服务器返回，用来告诉浏览器在这个时间点之前可以直接从缓存里面获取数据，而无需再次请求.
- 如下,表示资源在2019年11月22号8点41分过期，过期后需要想服务端发送请求
```js
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```
- 如果本地时间被修改，会导致缓存失效。
- 或者浏览器的时间和服务器时间不一致，可能会导致过期时间不准确的问题，所以http1.1中使用Cache-Control代替

**Cache-Control**
- http1.1中使用Cache-Control代替Expires,本质不同在于Cache-Control采用的是相对时间来控制华村，对应字段是max-age，如下，表示资源在3600秒后过期，过期后需要向服务端发送请求
```js
Cache-Control: max-age=3600
```
- Cache-Control的值可以是多个，多个值之间用逗号隔开，如下
  - private：表示资源只能被浏览器缓存，不能被代理服务器缓存
  - no-cache：跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段
  - no-store：禁止浏览器和代理服务器缓存当前的请求返回的结果，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源
  - s-maxage：覆盖max-age或者Expires头，但是仅适用于共享缓存（比如CDN缓存、代理服务器等），私有缓存（比如浏览器缓存）会忽略它
  - public：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存
> 注意：当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑，即Cache-Control的值会覆盖Expires的值




#### 协商缓存
强缓存过期之后会使用协商缓存，协商缓存需要客户端向服务端发送请求，资源未过期则服务端返回304否则返回新的资源。 协商缓存也有两种实现方案：
* Last-Modified 和 If-Modified-Since：
  * Last-Modified 表示最后修改日期，在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段.
  * If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。否则返回304，告诉浏览器使用缓存。但是如果本地文件被打开，会导致Last-Modified 被修改。
* ETag 和 If-None-Match：
  * ETag 类似于文件指纹，是服务器根据当前文件内容生成的唯一标识，只要内容有改动，Etag就会变化。服务器在响应头中加上这个字段，传给浏览器。
  * 浏览器在接收Etag的值后，在下一次请求时，会将该值作为If-None-Match字段的内容，放到请求头中发送给服务器，询问该资源 ETag 是否变动
  * 服务器在接收到If-None-Match后，会跟服务器上该资源的ETag进行比,有变动的话就将新的资源发送回来,没有变动则返回304告诉浏览器使用缓存。并且 **ETag 优先级比 Last-Modified 高**。

**对比：**
* 精准度：Etag > Last-Modified，因为ETag是根据文件内容生成的指纹，能准确感知资源的变化。而Last-Modified 在一些特殊的情况并不能准确感知资源变化:
  * 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效
  * Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
* 性能：Last-Modified > Etag，因为Etag需要服务器通过算法来计算资源的指纹(hash)，而Last-Modified 只需要记录修改时间即可。

#### 缓存位置
浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是:
* Service Worker
  * Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM
  * 可以帮助完成离线缓存、消息推送和网络代理等功能
  * 其中离线缓存就是通过 Service Worker 实现的，它可以让我们的应用在离线状态下依然可用，这也是 (PWA)[https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps] 的核心功能之一
* Memory Cache
  * 即内存缓存，从效率上讲，内存缓存是最快的一种缓存，但是缓存持续的时间也是最短的，当渲染进程结束后，内存缓存也就不存在了
* Disk Cache
  * 即存储在硬盘中的缓存，相比内存缓存，它的优势在于存储容量和时效性，但是相对于内存缓存来说，它的读取速度就慢了很多
* Push Cache
  * 即推送缓存，这是浏览器缓存中最后一个环节，它只在 https 协议下存在，而且缓存时间也很短暂，只在会话(session)存在，一旦会话结束就被释放，所以它只能用来处理一些非关键性的资源，比如说页面的图标、样式等等

浏览器对于Memory Cache 和 Disk Cache缓存策略：
- 较大的JS、CSS文件会被缓存到硬盘中，而不是内存中
- 内存使用频率较高时，文件优先进入磁盘缓存

### 浏览器本地存储
> 浏览器本地存储主要分为cookie、web storage、indexDB，其中web storage又分为localStorage和sessionStorage

#### Cookie
产生的背景：
* HTTP协议是无状态的，每次请求都是独立的，服务器无法知道当前请求和上一次请求是否来自同一个浏览器，所以无法知道用户的状态
* 为了解决这个问题，服务器可以通过设置响应头的Set-Cookie字段，将用户的状态信息以Cookie的形式发送给浏览器，浏览器会将Cookie保存起来，当下次请求时，会将Cookie发送给服务器，服务器就能知道用户的状态了
* Cookie 是由服务器生成，发送给浏览器的一小段文本信息，浏览器会把 Cookie 保存起来，之后每次请求都会将 Cookie 发送给服务器。其本质就是浏览器存储的一个很小的文本文件，内部以键值对的方式来存储数据

作用： 存储会话状态（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
缺陷:
  * 容量缺陷：每个域名下的 Cookie 数量和大小都是有限制的，不同浏览器的限制也不一样，一般来说不超过 50 个，单个域名下不超过 4KB
  * 性能缺陷：Cookie紧跟域名，不管该域名下的某个地址需不需要这个Cookie,请求都会携带该Cookie，这样随着请求数的增加，会带来性能上的损耗
  * 安全缺陷：Cookie 存储在浏览器中，容易被恶意获取，然后进行篡改，所以 Cookie 中存储的信息一般都是一些不敏感的信息，如用户的登录状态等。且Cookie是明文传输，容易被窃取。在httpOnly为false的情况下，Cookie 信息能直接通过 JS 脚本来读取,容易受到XSS攻击

#### localStorage
* localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新技术，早在 IE6 时代就已经存在了，只不过当时叫做 userData，是 IE 浏览器独有的技术，后来被 HTML5 标准化，改名为 localStorage
和cookie相同点：
* 都是针对某个域名进行存储的
和cookie不同点：
* cookie 是在浏览器和服务器之间来回传递的，而 localStorage 是完全位于浏览器端的，数据不会随着 HTTP 请求被发送出去
* localStorage 的容量比 cookie 大得多，可以达到 5MB 以上，cookie 只有 4KB
* localStorage暴露在全局，通过setItem和getItem方法来进行操作，非常方便，而cookie只能通过document.cookie来进行操作。

[API方法参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)
应用场景：利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源

#### sessionStorage
和localStorage的区别：
* sessionStorage 也是 HTML5 标准中新加入的技术，它和 localStorage 的接口类似，但是保存数据的生命周期与 localStorage 不同，它只是将数据保存在当前会话中，当会话结束（通常是窗口关闭）时，数据也随之被清除

相同点：
* 都是针对某个域名进行存储的
* 容量都比较大，可以达到 5MB 以上
* 只存储在客户端，默认不会发送到服务器端
* 接口方法也类似，都是通过setItem和getItem方法来进行操作，[API方法参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage)

#### IndexedDB
- IndexedDB 是 HTML5 标准中新加入的技术，它是一种本地（非关系型）数据库，可以在浏览器中存储结构化数据，提供比 localStorage 更强的查询功能，这些查询功能允许开发者使用索引来检索数据
- 其容量理论上没有上限，但是不同浏览器实现上有所差异，一般来说不少于 250MB
- [IndexedDB使用指南](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API)

注意：
* 键值对存储，内部采用对象仓库（object store）存放数据，在这个对象仓库中的数据采用键值对的方式进行存储
* 异步操作，IndexedDB 的 API 设计采用了异步架构，所有的操作都是异步执行的，这样可以避免大量数据的读写阻塞主线程，从而提升性能
* IndexedDB 也是遵循同源策略的，每一个数据库都是和创建它的域名绑定的，不同域名之间无法互相访问对方的数据库

#### 总结
- cookie并不适合存储，而且存在非常多的缺陷。
- Web Storage包括localStorage和sessionStorage, 默认不会参与和服务器的通信。
- IndexedDB为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口




### OSI七层模型和TCP/IP四层模型

七层模型：
* 应用层
* 表示层
* 会话层
* 传输层
* 网络层
* 数据链路层
* 物理层


四层模型：
* 应用层：应用层、表示层、会话层：HTTP
* 传输层：传输层：TCP/UDP
* 网络层：网络层：IP
* 数据链路层：数据链路层、物理层


### http响应头和请求头
参考：
- https://juejin.cn/post/7124847588070653983
**HTTP Request Header 常见的请求头：**

Accept:浏览器能够处理的内容类型
Accept-Charset:浏览器能够显示的字符集
Accept-Encoding：浏览器能够处理的压缩编码
Accept-Language：浏览器当前设置的语言
Connection：浏览器与服务器之间连接的类型
Cookie：当前页面设置的任何Cookie
Host：发出请求的页面所在的域
Referer：发出请求的页面的URL
User-Agent：浏览器的用户代理字符串

**HTTP Responses Header 常见的响应头：**

Date：表示消息发送的时间，时间的描述格式由rfc822定义
server:服务器名称
Connection：浏览器与服务器之间连接的类型
Cache-Control：控制HTTP缓存
content-type:表示后面的文档属于什么MIME类型

**常见的 Content-Type 属性值有以下四种：**
（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。
（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。
（3）application/json：服务器消息主体是序列化后的 JSON 字符串。
（4）text/xml：该种方式主要用来提交 XML 格式的数据。

### 常见攻击类型
* [XSS](https://juejin.cn/post/6844903685122703367)


### cookie


### HTTP 1.0 和 HTTP 1.1 之间有哪些区别
- 连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- 资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- 缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
- http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。

### HTTP 1.1 和 HTTP 2.0 的区别

- 二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
- 多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"**队头堵塞**"的问题。
- 数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
- 头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
- 服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

**队头堵塞**：
> 队头阻塞是由 HTTP 基本的“请求 - 响应”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。


### HTTP和HTTPS协议的区别
HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

### 对keep-alive的理解
HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是长连接。其使用方法如下：

-HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送Connection: keep-alive字段。若想断开keep-alive连接，需发送Connection:close字段；
- HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送Connection：close首部字段。

**Keep-Alive的建立过程**：

- 客户端向服务器在发送请求报文同时在首部添加发送Connection字段
- 服务器收到请求并处理 Connection字段
- 服务器回送Connection:Keep-Alive字段给客户端
- 客户端接收到Connection字段
- Keep-Alive连接建立成功

**服务端自动断开过程（也就是没有keep-alive）**：

- 客户端向服务器只是发送内容报文（不包含Connection字段）
- 服务器收到请求并处理
- 服务器返回客户端请求的资源并关闭连接
- 客户端接收资源，发现没有Connection字段，断开连接

**客户端请求断开连接过程**：

- 客户端向服务器发送Connection:close字段
- 服务器收到请求并处理connection字段
- 服务器回送响应资源并断开连接
- 客户端接收资源并断开连接

**开启Keep-Alive的优点**：

- 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
- 允许请求和应答的HTTP管线化；
- 降低拥塞控制 （TCP连接减少了）；
- 减少了后续请求的延迟（⽆需再进⾏握⼿）；
- 报告错误⽆需关闭TCP连；

**开启Keep-Alive的缺点**：

长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。


###  HTTP2的头部压缩算法是怎样的
HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。
具体来说:

在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；
首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；
每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。

例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。
![http2头部压缩算法](../00_images/network/http2-head-compress-algorithm.png)


### http请求报文和相应报文
#### 请求报文
请求报⽂有4部分组成:
- 请求⾏
- 请求头部
- 空⾏
- 请求体
![request-message](../00_images/network/request-message.png)
其中：
（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。
（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔
User-Agent：产⽣请求的浏览器类型。
Accept：客户端可识别的内容类型列表。
Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。
（3）请求体: post put等请求携带的数据
![request-message-example](../00_images/network/request-message-example.png)

#### 响应报文
响应报⽂有4部分组成:
- 响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。
- 响应头：响应部⾸组成
- 空⾏
- 响应体：服务器响应的数据
![response-message](../00_images/network/response-message.png)


### http协议优缺点
HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。
HTTP协议具有以下优点：

支持客户端/服务器模式
简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
无状态：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

HTTP协议具有以下缺点：

无状态： HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
明文传输： 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
不安全

（1）通信使用明文（不加密），内容可能会被窃听；
（2）不验证通信方的身份，因此有可能遭遇伪装；
（3）无法证明报文的完整性，所以有可能已遭篡改；
