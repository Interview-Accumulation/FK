### 编译时加载 和 运行时加载
- 编译时加载：在程序运行之前，模块的依赖关系就已经确定了，所以无法在运行时改变
- 运行时加载：只有在程序运行时，才能得到模块的依赖关系，以及导入的变量

> 阮一峰在es6module篇中描述：ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。

- CommonJS 模块就是对象，输入时必须查找对象属性
```js
// CommonJS模块
let { stat, exists, readfile } = require('fs');
// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```
- 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

- ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入
```js
// ES6模块
import { stat, exists, readFile } from 'fs';
```
- 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

-  ES6 模块是编译时加载，使得静态分析成为可能,能进一步拓宽 JavaScript 的语法,比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能


### 编译时 和 运行时
- 编译时：对程序语言进行翻译，进行词法分析、语法分析等，生成目标代码的过程。
  - 开始编译时,如果有errors或者warning信息,叫编译时错误.
  - 这个过程中做的类型检查也就叫编译时类型检查,或静态类型检查，此过程没把真把代码放内存中运行起来,而只是把代码当作文本来扫描下,看看有没有错误.
- 运行时： 可理解为代码装载到内存中去运行的时候。运行时错误就是代码运行时发生的错误。
  - 运行时错误是指程序在运行时发生的错误,比如除数为0,数组越界,空指针等等.
  - 运行时类型检查,或动态类型检查,是指在代码运行起来后,对代码中的类型进行检查,比如在运行时,对一个变量赋值了一个不同类型的值,就会报错.

  ### 工程项目依赖包问题
  #### 使用pnpm避免幻影依赖问题
  - 幻影依赖：npm将依赖包及依赖包所依赖的包，使用拍平的方式，均放在`node_modules`文件夹下，使得自身项目并未安装某个包，但某个依赖包安装了这个包，在项目中能直接引入并使用，若该依赖包版本升级，使用这个自身未安装的包可能会出问题。
  pnpm使用文件连接的方式，将所有项目依赖的包，其自身的依赖包均放入`.pnpm`文件夹中，这样项目就不能使用某个项目自身未依赖的包，即使这个包被某个依赖安装了